<?xml version="1.0" encoding="UTF-8"?>
<!--
   - ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is calendar views.
   -
   - The Initial Developer of the Original Code is
   -   Oracle Corporation
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   Vladimir Vukicevic <vladimir@pobox.com>
   -   Stefan Sitter <ssitter@googlemail.com>
   -   Clint Talbert <cmtalbert@myfastmail.com>
   -   Michael Buettner <michael.buettner@sun.com>
   -   Philipp Kewisch <mozilla@kewis.ch>
   -   Markus Adrario <MarkusAdrario@web.de>
   -   Berend Cornelius <berend.cornelius@sun.com>
   -   Martin Schroeder <mschroeder@mozilla.x-home.org>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
-->

<!-- Note that this file depends on helper functions in calUtils.js-->

<!DOCTYPE bindings SYSTEM "chrome://global/locale/global.dtd" >

<bindings id="calendar-year-view-bindings"
  xmlns="http://www.mozilla.org/xbl"
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
  xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:xbl="http://www.mozilla.org/xbl">

  <!-- custom calendar-day-label -->
  <binding id="calendar-year-day-label" extends="xul:box">
    <content flex="1" pack="center">
      <xul:label anonid="longWeekdayName" class="calendar-day-label-name" xbl:inherits="selected"/>
      <xul:label anonid="shortWeekdayName" class="calendar-day-label-name" hidden="true" xbl:inherits="selected"/>
    </content>
    <implementation>
      <field name="mWeekday">-1</field>
      <field name="longWeekdayPixels">0</field>
      <field name="mDate">null</field>
      <property name="longName" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'longWeekdayName');"/>
      <property name="shortName" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'shortWeekdayName');"/>
      <property name="weekDay">
        <getter>return this.mWeekday;</getter>
        <setter><![CDATA[
          this.mWeekday = val % 7;
          this.longName.value = cal.getDateFormatter().dayName(val)[0];
          this.shortName.value = cal.getDateFormatter().shortDayName(val)[0];
          return this.mWeekday;
        ]]></setter>
      </property>

      <property name="date">
        <getter><![CDATA[
          return this.mDate;
        ]]></getter>
        <setter><![CDATA[
          this.mDate = val;
          this.shortName.setAttribute("value", cal.getDateFormatter().shortDayName(val.weekday) + " " +
                                               cal.getDateFormatter().formatDateWithoutYear(val));
          this.longName.setAttribute("value", cal.getDateFormatter().dayName(val.weekday) + " " +
                                              cal.getDateFormatter().formatDateWithoutYear(val));
          return val;
        ]]></setter>
      </property>

      <property name="shortWeekNames">
        <getter><![CDATA[
        ]]></getter>
        <setter><![CDATA[
          // cache before change, in case we are switching to short
          this.getLongWeekdayPixels();
          setBooleanAttribute(this.longName, "hidden", val);
          setBooleanAttribute(this.shortName, "hidden", !val);
          return val;
        ]]></setter>
      </property>

      <method name="getLongWeekdayPixels">
        <body><![CDATA[
          // Only do this if the long weekdays are visible and we haven't already cached.
          let longNameWidth = this.longName.boxObject.width;
          if (longNameWidth > 0) {
              this.longWeekdayPixels = longNameWidth +
                                       getSummarizedStyleValues(this.longName, ["margin-left", "margin-right"]);
              this.longWeekdayPixels += getSummarizedStyleValues(this, ["border-left-width",
                                                                        "padding-left", "padding-right"]);
              return this.longWeekdayPixels;
          } else {
              // in this case the weekdaypixels have not yet been layouted;
              // by definition 0 is returned
              return 0;
          }
        ]]></body>
      </method>
    </implementation>
  </binding>


  <binding id="calendar-year-day-box-item" extends="chrome://calendar/content/calendar-view-core.xml#calendar-editable-item">
    <content mousethrough="never" tooltip="itemTooltip">
      <xul:vbox flex="1">
        <xul:hbox>
          <xul:box anonid="event-container"
                   class="calendar-color-box"
                   xbl:inherits="calendar-uri,calendar-id"
                   flex="1">
            <xul:box class="calendar-event-selection" orient="horizontal" flex="1">
              <xul:stack anonid="eventbox"
                         class="calendar-event-box-container"
                         xbl:inherits="readonly,flashing,alarm,allday,priority,progress,status,calendar,categories"
                         flex="1">
                <xul:hbox class="calendar-event-details">
                  <xul:vbox pack="center">
                    <xul:image anonid="item-icon"
                               class="calendar-month-day-box-item-image"
                               xbl:inherits="progress,allday"/>
                  </xul:vbox>
                  <xul:label anonid="item-label"
                             class="calendar-month-day-box-item-label"
                             xbl:inherits="context"/>
                  <xul:vbox align="left"
                            flex="1"
                            xbl:inherits="context">
                    <xul:label anonid="event-name"
                               crop="end"
                               flex="1"
                               style="margin: 0;"/>
                    <xul:textbox anonid="event-name-textbox"
                                 class="plain calendar-event-name-textbox"
                                 crop="end"
                                 hidden="true"
                                 wrap="true"/>
                    <xul:spacer flex="1"/>
                  </xul:vbox>
                  <xul:stack>
                    <xul:calendar-category-box anonid="category-box" xbl:inherits="categories" pack="end"/>
                    <xul:hbox anonid="alarm-icons-box"
                              class="alarm-icons-box"
                              align="center"
                              pack="end"
                              xbl:inherits="flashing"/>
                  </xul:stack>
                </xul:hbox>
                <xul:image anonid="gradient"
                           class="calendar-event-box-gradient"
                           height="1px"
                           mousethrough="always"/>
              </xul:stack>
            </xul:box>
          </xul:box>
        </xul:hbox>
      </xul:vbox>
    </content>
    <implementation>
      <constructor><![CDATA[
          ChromeUtils.import("resource://calendar/modules/calUtils.jsm");
      ]]></constructor>

      <property name="occurrence">
        <getter><![CDATA[
            return this.mOccurrence;
        ]]></getter>
        <setter><![CDATA[
            cal.ASSERT(!this.mOccurrence, "Code changes needed to set the occurrence twice", true);
            this.mOccurrence = val;
            if (cal.item.isEvent(val)) {
                if (!val.startDate.isDate) {
                    let label = document.getAnonymousElementByAttribute(this, "anonid", "item-label");
                    let formatter = Components.classes["@mozilla.org/calendar/datetime-formatter;1"]
                                              .getService(Components.interfaces.calIDateTimeFormatter);
                    let timezone = this.calendarView ? this.calendarView.mTimezone
                                                     : cal.dtz.defaultTimezone;
                    let parentDate = cal.dtz.ensureDateTime(this.parentBox.date);
                    let startTime = val.startDate.getInTimezone(timezone);
                    let endTime = val.endDate.getInTimezone(timezone);
                    let nextDay = parentDate.clone();
                    nextDay.day++;
                    let comp = endTime.compare(nextDay);
                    if (startTime.compare(parentDate) == -1) {
                        if (comp == 1) {
                            label.value = "â†”";
                        } else if (comp == 0) {
                            label.value = "â†¤";
                        } else {
                            label.value = "â‡¥ " + formatter.formatTime(endTime);
                        }
                    } else if (comp == 1) {
                        label.value = "â‡¤ " + formatter.formatTime(startTime);
                    } else {
                        label.value = formatter.formatTime(startTime);
                    }
                    label.setAttribute("time", "true");
                }
            }

            this.setEditableLabel();
            this.setCSSClasses();
            return val;
        ]]></setter>
      </property>
      <property name="parentBox"
                onget="return this.mParentBox;"
                onset="this.mParentBox = val;"/>
    </implementation>
  </binding>

  <binding id="calendar-year-day-box" extends="chrome://calendar/content/widgets/calendar-widgets.xml#dragndropContainer">
		<content orient="vertical">
			<xul:hbox>
				<xul:label anonid="week-label"
					flex="1" crop="end" hidden="true" mousethrough="always"
					class="calendar-month-day-box-week-label calendar-month-day-box-date-label"
					xbl:inherits="relation,selected" />
				<xul:label anonid="day-label"
					flex="1" crop="end" mousethrough="always"
					class="calendar-month-day-box-date-label"
					xbl:inherits="relation,selected,value" />
			</xul:hbox>
			<xul:vbox anonid="day-items" class="calendar-year-day-box-items-box"
				flex="1">
				<children />
			</xul:vbox>
			<xul:label anonid="day-more" class="calendar-year-day-box-more-off"
				value=" " />
		</content>

    <implementation>
      <field name="mDate">null</field>
      <!-- mItemData will always be kept sorted in display order -->
      <field name="mItemData">[]</field>
      <field name="mShowMonthLabel">false</field>
      <field name="mPresentHashes">[]</field>

      <property name="date">
        <getter>return this.mDate;</getter>
        <setter>this.setDate(val); return val;</setter>
      </property>

      <property name="selected">
        <getter><![CDATA[
          var sel = this.getAttribute("selected");
          if (sel && sel == "true") {
            return true;
          }

          return false;
        ]]></getter>
        <setter><![CDATA[
          if (val)
            this.setAttribute("selected", "true");
          else
            this.removeAttribute("selected");
          return val;
        ]]></setter>
      </property>

      <property name="dayitems">
        <getter>return document.getAnonymousElementByAttribute(this, "anonid", "day-items");</getter>
      </property>
      <property name="morelabel">
        <getter>return document.getAnonymousElementByAttribute(this, "anonid", "day-more");</getter>
      </property>

      <property name="showMonthLabel">
        <getter><![CDATA[
          return this.mShowMonthLabel;
        ]]></getter>
        <setter><![CDATA[
          if (this.mShowMonthLabel == val) {
            return val;
          }
          this.mShowMonthLabel = val;

          if (!this.mDate) {
            return val;
          }

          this.setAttribute("value", this.mDate.day);
          return val;
        ]]></setter>
      </property>


      <method name="setDate">
        <parameter name="aDate"/>
        <body><![CDATA[

            // Remove all the old events
            this.mItemData = new Array();
            while(this.hasChildNodes()) {
                this.removeChild(this.lastChild);
            }
            // Reset more
            this.morelabel.setAttribute("class","calendar-year-day-box-more-off");
            this.morelabel.setAttribute("tooltiptext","");

            if (!aDate) {
                //throw Components.results.NS_ERROR_NULL_POINTER;
                this.setAttribute("value", "");
                return;
            }
            if (this.mDate && this.mDate.compare(aDate) == 0)
                return;

            this.mDate = aDate;

            this.setAttribute("value", aDate.day);
        ]]></body>
      </method>

      <method name="addItem">
        <parameter name="aItem"/>
        <body><![CDATA[
          // skip item if hidden in this view
          if (aItem.calendar.getProperty('yearview.hide')===true)
            return;

          if (this.mPresentHashes.indexOf(aItem.hashId) > -1)Â {
              this.deleteItem(aItem);
          }

          this.mItemData.push({item:aItem});
          this.mPresentHashes.push(aItem.hashId);
          this.relayout();
        ]]></body>
      </method>

      <method name="selectItem">
        <parameter name="aItem"/>
        <body><![CDATA[
          this.mItemData.forEach(itd => {
              if (aItem && (itd.item.hashId == aItem.hashId)) {
                  itd.box.selected = true;
              }
          });
        ]]></body>
      </method>

      <method name="unselectItem">
        <parameter name="aItem"/>
        <body><![CDATA[
          this.mItemData.forEach(itd => {
              if (aItem && (itd.item.hashId == aItem.hashId)) {
                  itd.box.selected = false;
              }
          });
        ]]></body>
      </method>

      <method name="deleteItem">
        <parameter name="aItem"/>
        <body><![CDATA[
          var deleted = [];

          var origLen = this.mItemData.length;
          this.mItemData = this.mItemData.filter(function(itd) {
              if (aItem.hashId == itd.item.hashId)
              {
                deleted.push(itd);
                return false;
              }
              return true;
          });

          if (deleted.length > 0) {
            this.mPresentHashes.splice( this.mPresentHashes.indexOf(aItem.hashId) , 1 );

            deleted.forEach(itd => {
              if (itd.box)
                this.removeChild(itd.box);
            });
            // no need to relayout; all we did was delete
            //this.relayout();
          }
        ]]></body>
      </method>

      <method name="relayout">
        <body><![CDATA[
            var df = Components.classes["@mozilla.org/calendar/datetime-formatter;1"].
                           getService(Components.interfaces.calIDateTimeFormatter);
            var timezone = this.calendarView ? this.calendarView.mTimezone : calendarDefaultTimezone();

            var yearView = this.mCalendarView || document.getElementById("year-view");

            var tooltip="";


            /* Order day boxes, try to keep same position over days
             * this will make redraw slower than ever.
             */

            // empty child nodes... more time
            while(this.childNodes.length > 0) this.removeChild(this.childNodes[0]);

            var needRelayout = [];

            var lastslot = -1;
            var slots = {};
            for (var i = 0; i < this.mItemData.length; i++) {
                var itd = this.mItemData[i];
                var itdslot = yearView.mItemsSlot[itd.item.hashId];

                if (itdslot !== undefined && slots[itdslot] !== undefined) {
                    // we have duplicated slots. let's reset this item slot and
                    // later run a relayout of all of this item day boxes..
                    yearView.mItemsSlot[itd.item.hashId] = undefined;
                    yearView.mItemsSlot[slots[itdslot].item.hashId] = undefined
                    needRelayout.push(itd);
                    needRelayout.push(slots[itdslot])
                    delete slots[itdslot]

                    itdslot = undefined;
                }

                if ( itdslot !== undefined) {
                    slots[itdslot] = itd;
                    if (itdslot > lastslot) lastslot = itdslot;
                }

            }

            // fill slots
            for (var i = 0; i < this.mItemData.length; i++) {
                var itd = this.mItemData[i];

                var slot = yearView.mItemsSlot[itd.item.hashId];

                if (slot === undefined) {
                    // no previous slot. find first free
                    slot = lastslot+1;
                    for(var j = 0; j < lastslot+1; j++){
                        if (slots[j] === undefined) {
                            slot = j;
                            break;
                        }
                    }
                    yearView.mItemsSlot[itd.item.hashId] = slot;
                }

                slots[slot] = itd;
                if (slot > lastslot) lastslot = slot;
            }

            for (var i = 0; i < lastslot + 1; i++ ) {
                var itd = slots[i];

                if (itd === undefined) {

                    var box = createXULElement("xul:box");
                    box.setAttribute("class", "calendar-year-day-box-item-empty");
                    box.parentBox = this;
                    slot[i] = { box: box }
                    this.insertBefore(box, null);
                    continue;
                }

                if (itd.box) {
                    delete itd.box;
                }

                var box = createXULElement("calendar-year-day-box-item");
                box.setAttribute("context", this.getAttribute("item-context") || this.getAttribute("context"));
                box.setAttribute("calendar-uri", itd.item.calendar.uri.spec);
                box.setAttribute("calendar-id", itd.item.calendar.id);

                if (cal.item.isEvent(itd.item)) {
                    var tomorrow = this.mDate.clone(); tomorrow.day++;

                    if (itd.item.startDate.compare(this.mDate)==0) box.classList.add("day-box-item-start");
                    if (itd.item.endDate.compare(this.mDate)==0) box.classList.add("day-box-item-end");
                    if (itd.item.endDate.isDate && itd.item.endDate.compare(tomorrow)==0) box.classList.add("day-box-item-end");
                } else {
                    box.classList.add("day-box-item-start");
                    box.classList.add("day-box-item-end");
                }

                this.insertBefore(box, null);

                box.calendarView = this.calendarView;
                box.item = itd.item;
                box.parentBox = this;
                box.occurrence = itd.item;
                itd.box = box;

                tooltip += itd.item.title+"\n";

            }

            for(var j=0; j < needRelayout.length; j++) {
                boxes = yearview.findDayBoxesForItem(needRelayout[j].item);
                for(var k=0; k < boxes.length; k++) {
                    if (boxes[k] !== this) boxes.relayout();
                }
            }
            // needs more?
            if (this.mItemData.length > 0 && this.dayitems.clientHeight < (this.mItemData[0].box.clientHeight * this.mItemData.length)){
                this.morelabel.setAttribute("class","calendar-year-day-box-more-on");
                this.morelabel.setAttribute("tooltiptext", tooltip);
            } else {
                this.morelabel.setAttribute("class","calendar-year-day-box-more-off");
            }

        ]]></body>
      </method>
      <method name="onDropItem">
        <parameter name="aItem"/>
        <body><![CDATA[
          return cal.moveItem(aItem, this.mDate);
        ]]></body>
      </method>

    </implementation>

    <handlers>
      <handler event="mousedown"><![CDATA[
        event.stopPropagation();
        if (this.mDate)
          this.calendarView.selectedDay = this.mDate;
      ]]></handler>
      <handler event="dblclick"><![CDATA[
        event.stopPropagation();
        this.calendarView.controller.createNewEvent();
      ]]></handler>
      <handler event="click" button="0"><![CDATA[
        this.calendarView.setSelectedItems(0, []);
      ]]></handler>
      <handler event="DOMMouseScroll"><![CDATA[
        if (getParentNodeOrThisByAttribute(event.originalTarget, "anonid", "day-label") == null) {
            if (this.dayitems.scrollHeight > this.dayitems.clientHeight) {
                event.stopPropagation();
            }
        }
      ]]></handler>
    </handlers>
  </binding>

  <binding id="calendar-year-base-view" extends="chrome://calendar/content/calendar-base-view.xml#calendar-base-view">
    <content style="overflow: auto" flex="1" xbl:inherits="context,item-context">
      <xul:vbox anonid="mainbox" flex="1">
        <xul:hbox class="labeldaybox-container"
                  anonid="labeldaybox"
                  chromedir="&locale.dir;"
                  equalsize="always" />

        <xul:grid anonid="yeargrid" flex="1">
          <xul:columns anonid="yeargridcolumns" equalsize="always" />
          <xul:rows anonid="yeargridrows" equalsize="always" />
        </xul:grid>
      </xul:vbox>


    </content>

    <implementation implements="calICalendarView">

      <!-- constructor -->
      <constructor><![CDATA[
        Components.utils.import("resource://gre/modules/Preferences.jsm");
        Components.utils.import("resource://calendar/modules/calUtils.jsm");

         // Set the preference for the default start of the week
         this.weekStartOffset = Preferences.get("calendar.week.start", 0);
         /*
          for (var i = 0; i < 7; i++) {
            let hdr = createXULElement("calendar-day-label");
            this.labeldaybox.appendChild(hdr);
            hdr.weekDay = (i + this.mWeekStartOffset) % 7;
            hdr.shortWeekNames = false;
          }*/

         var maxday=37;

         // header "month name"
         var hdr = createXULElement("calendar-day-label");
         this.labeldaybox.appendChild(hdr);
         hdr.shortWeekNames = true;

         // week day name heads
         for (var i=0; i<maxday; i++){
            var hdr = createXULElement("calendar-year-day-label");
            this.labeldaybox.appendChild(hdr);
            hdr.weekDay = i % 7;
            hdr.shortWeekNames = true;
         }

         /* columns */
         yeargridcolumns =  document.getAnonymousElementByAttribute(this, "anonid", "yeargridcolumns");
         for (var d=0; d<maxday+1; d++) {
            var col = createXULElement("column");
            col.setAttribute("flex", "1");
            col.setAttribute("class", "calendar-month-view-grid-column");
            yeargridcolumns.appendChild(col);
         }

         //yeargridrows =  document.getAnonymousElementByAttribute(this, "anonid", "yeargridrows");
         /* righe e giorni */
         for (var m=0; m<12; m++) {
            var row = createXULElement("row");
            row.setAttribute("flex","1");
            row.setAttribute("class", "calendar-month-view-grid-row");

            var day = createXULElement("label");
            day.setAttribute("flex","1");
            var monthName = cal.l10n.getAnyString("calendar", "dateFormat", "month." + (m+1) + ".Mmm");
            day.setAttribute("value",monthName);
            row.appendChild(day);

            for (var d=0; d<maxday; d++) {
               var day = createXULElement("calendar-year-day-box");
               row.appendChild(day);
            }
            this.yeargridrows.appendChild(row);
         }


        // Set the preference for displaying the week number
        this.mShowWeekNumber = Preferences.get("calendar.view-minimonth.showWeekNumber", true);

        this.mItemsSlot = {};


        // get all calendars and add an observer
        console.log("calendars", cal.getCalendarManager().getCalendars({}));
        cal.getCalendarManager().getCalendars({}).forEach(aCalendar => {
          console.log("add observer to", aCalendar.id);
          aCalendar.addObserver(this.calObserver);
        });

      ]]></constructor>

      <!-- fields -->
      <field name="mDateBoxes">null</field>
      <field name="mSelectedDayBox">null</field>

      <field name="mShowDaysOutsideMonth">true</field>
      <field name="mShowFullMonth">true</field>

      <field name="mItemsSlot">null</field>

      <field name="calObserver"><![CDATA[
        ({
            calYearView: this,
            QueryInterface: XPCOMUtils.generateQI([Components.interfaces.calIObserver]),

            // calIObserver. Note that each registered calendar uses this observer
            onStartBatch: function() { },
            onEndBatch: function() { },
            onLoad: function() { },

            onAddItem: function(aItem) { },
            onModifyItem: function(aNewItem, aOldItem) { },
            onDeleteItem: function(aDeletedItem) { },
            onError: function(aCalendar, aErrNo, aMessage) { },

            onPropertyChanged: function(aCalendar, aName, aValue, aOldValue) {
                switch (aName) {
                    case "yearview.hide":
                      this.calYearView.refreshView();
                }
            },

            onPropertyDeleting: function(aCalendar, aName) {
                // Since the old value is not used directly in onPropertyChanged,
                // but should not be the same as the value, set it to a different
                // value.
                this.onPropertyChanged(aCalendar, aName, null, null);
            }
        })
      ]]></field>

      <!-- other methods -->
      <method name="setAttribute">
        <parameter name="aAttr"/>
        <parameter name="aVal"/>
        <body><![CDATA[
          var needsrelayout = false;
          if (aAttr == "context" || aAttr == "item-context")
              needsrelayout = true;

          var ret = XULElement.prototype.setAttribute.call (this, aAttr, aVal);

          if (needsrelayout)
              this.relayout();

          return ret;
        ]]></body>
      </method>

      <!-- calICalendarView -->

      <property name="supportsDisjointDates" readonly="true"
                onget="return false;"/>
      <property name="hasDisjointDates" readonly="true"
                onget="return false;"/>

      <property name="startDate" readonly="true"
                onget="return this.mStartDate"/>

      <property name="endDate" readonly="true"
                onget="return this.mEndDate"/>

      <property name="showFullMonth">
        <getter><![CDATA[
          return this.mShowFullMonth;
        ]]></getter>
        <setter><![CDATA[
          this.mShowFullMonth = val;
          return val;
        ]]></setter>
      </property>

      <!-- this property may be overridden by the
          descendent classes if neeeded  -->
      <property name="weeksInView">
        <getter><![CDATA[
            return 0;
        ]]></getter>
        <setter><![CDATA[
            return val;
        ]]></setter>
      </property>

      <method name="handlePreference">
        <parameter name="aSubject"/>
        <parameter name="aTopic"/>
        <parameter name="aPreference"/>
        <body><![CDATA[
           aSubject.QueryInterface(Components.interfaces.nsIPrefBranch);

           switch (aPreference) {
               case "calendar.previousweeks.inview":
                   this.updateDaysOffPrefs();
                   this.refreshView();
                   break;

               case "calendar.week.start":
                   this.weekStartOffset = aSubject.getIntPref(aPreference);
                   // Refresh the view so the settings take effect
                   this.refreshView();
                   break;

               case "calendar.weeks.inview":
                   this.weeksInView = aSubject.getIntPref(aPreference);
                   break;

               case "calendar.previousweeks.inview":
                   this.refreshView();
                   break;

              case "calendar.view-minimonth.showWeekNumber":
                  this.mShowWeekNumber = aSubject.getBoolPref(aPreference);
                  if (this.mShowWeekNumber) {
                      this.refreshView();
                  } else {
                      this.hideWeekNumbers();
                  }
                  break;

               default:
                   this.handleCommonPreference(aSubject, aTopic, aPreference);
                   break;
           }
           return;
        ]]></body>
      </method>

      <method name="getSelectedItems">
        <parameter name="aCount"/>
        <body><![CDATA[
          aCount.value = this.mSelectedItems.length;
          return this.mSelectedItems;
        ]]></body>
      </method>

      <method name="setSelectedItems">
        <parameter name="aCount"/>
        <parameter name="aItems"/>
        <parameter name="aSuppressEvent"/>
        <body><![CDATA[
          if (this.mSelectedItems.length) {
              this.mSelectedItems.forEach(item => {
                  let oldboxes = this.findDayBoxesForItem(item);
                  oldboxes.forEach(oldbox => {
                      oldbox.unselectItem(item);
                  });
              });
          }

          this.mSelectedItems = aItems || [];

          if (this.mSelectedItems.length) {
              this.mSelectedItems.forEach(item => {
                  let newboxes = this.findDayBoxesForItem(item);
                  newboxes.forEach(newbox => {
                      newbox.selectItem(item);
                  });
              });
          }

          if (!aSuppressEvent) {
              this.fireEvent("itemselect", this.mSelectedItems);
          }
        ]]></body>
      </method>

      <method name="centerSelectedItems">
        <body>
        </body>
      </method>

      <property name="selectedDay">
        <getter><![CDATA[
          if (this.mSelectedDayBox)
            return this.mSelectedDayBox.date.clone();

          return null;
        ]]></getter>
        <setter><![CDATA[
          if (this.mSelectedDayBox)
            this.mSelectedDayBox.selected = false;

          var realVal = val;
          if (!realVal.isDate) {
            realVal = val.clone();
            realVal.isDate = true;
          }
          let box = this.findDayBoxForDate(realVal);
          if (box) {
            box.selected = true;
            this.mSelectedDayBox = box;
          }
          this.fireEvent("dayselect", realVal);
          return val;
        ]]></setter>
      </property>

      <method name="showDate">
        <parameter name="aDate"/>
        <body><![CDATA[
            d1=aDate.clone();
            d1.day=1;
            d1.month=0;
            d2=d1.clone();
            d2.day=31;
            d2.month=11;
            this.setDateRange(d1, d2);
            this.selectedDay = aDate;
        ]]></body>
      </method>

      <method name="onResize">
        <parameter name="aBinding"/>
        <body><![CDATA[
          aBinding.adjustWeekdayLength();
        ]]></body>
      </method>

      <method name="setDateRange">
        <parameter name="aStartDate"/>
        <parameter name="aEndDate"/>
        <body><![CDATA[
         aStartDate.isDate=true;
         aEndDate.isDate=true;
         this.rangeStartDate = aStartDate;
         this.rangeEndDate = aEndDate;
         this.mStartDate = aStartDate; //getWeekInfoService().getStartOfWeek(aStartDate.getInTimezone(this.mTimezone))
         this.mEndDate = aEndDate; //getWeekInfoService().getEndOfWeek(aEndDate.getInTimezone(this.mTimezone));
         this.refresh();

         // Update the navigation bar.
         cal.navigationBar.setDateRange(aStartDate, aEndDate);
        ]]></body>
      </method>

      <method name="mylog">
         <parameter name="aMessage"/>
         <body><![CDATA[
            var consoleService = Components.classes["@mozilla.org/consoleservice;1"]
                                 .getService(Components.interfaces.nsIConsoleService);
            consoleService.logStringMessage(aMessage);
         ]]></body>
      </method>

      <method name="setDateList">
        <parameter name="aCount"/>
        <parameter name="aDates"/>
        <body><![CDATA[
           throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
        ]]></body>
      </method>

      <method name="getDateList">
        <parameter name="aCount"/>
        <body><![CDATA[
          if (!this.mStartDate || !this.mEndDate) {
            aCount.value = 0;
            return [];
          }

          let results = [];
          let curDate = this.mStartDate.clone();
          curDate.isDate = true;

          while (curDate.compare(this.mEndDate) <= 0) {
            results.push(curDate.clone());
            curDate.day += 1;
          }
          aCount.value = results.length;
          return results;
        ]]></body>
      </method>

      <!-- public properties and methods -->

      <!-- whether to show days outside of the current month -->
      <property name="showDaysOutsideMonth">
        <getter><![CDATA[
          return this.mShowDaysOutsideMonth;
        ]]></getter>
        <setter><![CDATA[
          if (this.mShowDaysOutsideMonth != val) {
            this.mShowDaysOutsideMonth = val;
            this.refresh();
          }
          return val;
        ]]></setter>
      </property>

      <!-- private properties and methods -->

      <property name="yeargrid" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'yeargrid');"/>

      <property name="yeargridrows" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'yeargridrows');"/>

      <method name="relayout">
        <body><![CDATA[
          if (this.mSelectedItems.length) {
            this.mSelectedItems = [];
          }


          // Clear out the old selection, since it won't be valid after relayout
          if (this.mSelectedDayBox) {
            this.mSelectedDayBox.selected = false;
          }

          if (!this.mStartDate || !this.mEndDate) {
            throw Components.results.NS_ERROR_FAILURE;
          }


          var dateBoxes = [];
          var today = this.today();

          // This gets set to true, telling us to collapse the rest of the rows
          var finished = false;
          var dateList = this.getDateList({})

          var rows = this.yeargridrows.childNodes;



          // Iterate through each monthgridrow and set up the day-boxes that
          // are its child nodes.  Remember, childNodes is not a normal array,
          // so don't use the in operator if you don't want extra properties
          // coming out.
          for (var i = 0; i < rows.length; i++) {
            var row = rows[i];

            rowdate = this.mStartDate.clone()
            rowdate.month = i;
            var date = rowdate.clone()


            for (var j = 1; j < row.childNodes.length; j++){
              row.childNodes[j].setAttribute("class","calendar-month-day-box-other-month");
              row.childNodes[j].setAttribute("relation","");
              row.childNodes[j].showMonthLabel = false;
              row.childNodes[j].setDate(null);

              let daybox_otherMonth = row.childNodes[j];
              daybox_class = daybox_otherMonth.getAttribute("class");
              let dayLabel_otherMonth = document.getAnonymousElementByAttribute(daybox_otherMonth, "anonid", "day-label");
              if (daybox_class == "calendar-month-day-box-other-month"){
                dayLabel_otherMonth.setAttribute("hidden","true");
              }
            }

            // used for week-label: display it only one time in each week:
            var currentWeekNumber = 0;

            for (var jj = rowdate.weekday; jj < rowdate.endOfMonth.day+rowdate.weekday; jj++) {
              j=jj+1;
              var daybox = row.childNodes[j];
              var daydate = date.clone()

              daybox.setAttribute("context", this.getAttribute("context"));
              daybox.setAttribute("item-context", this.getAttribute("item-context") || this.getAttribute("context"));

              // Set the box-class depending on if this box displays a day in
              // the month being currently shown or not.
              var boxClass = "calendar-month-day-box-current-month";

              function matchesDayOff(dayOffNum) { return dayOffNum == date.weekday; }
              if (this.mDaysOffArray.some(matchesDayOff)) {
                boxClass = "calendar-month-day-box-day-off " + boxClass;
              }

              // Set up date relations
              switch (date.compare(today)) {
                case -1:
                  daybox.setAttribute("relation", "past");
                  break;
                case 0:
                  daybox.setAttribute("relation", "today");
                  break;
                case 1:
                  daybox.setAttribute("relation", "future");
                  break;
              }

              daybox.setAttribute("class", boxClass);

              daybox.setDate(daydate);
              daybox.showMonthLabel = true;
              daybox.calendarView = this;

              //the daybox is a "current-month" (there's a date inside): unhide its day-label:
              let dayLabelCurrentMonth = document.getAnonymousElementByAttribute(daybox, "anonid", "day-label");
              dayLabelCurrentMonth.setAttribute("hidden","false");

              // WEEK LABEL:
              if (this.mShowWeekNumber) { // the user has chosen to display the week number
                let weekLabel = document.getAnonymousElementByAttribute(daybox, "anonid", "week-label");
                weekLabel.removeAttribute("hidden"); // display it
                let weekNumber = cal.getWeekInfoService().getWeekTitle(date);
                let weekString = cal.l10n.getAnyString("calendar", "calendar", "abbreviationOfWeek", [weekNumber]);
                if (currentWeekNumber != weekString){ // ...this is a new week
                  weekLabel.value = weekString; // so we display it
                  currentWeekNumber = weekString; // actualize the current week number
                }
              }

              //daybox.date = date;
              dateBoxes.push(daybox);

              /*
              var boxdata = {
                date: daydate,
                row: row,
                box: daybox
              };
              dateBoxes.push(boxdata);*/

              date.day += 1;

            }
          }


          // Store these, so that we can access them later
          this.mDateBoxes = dateBoxes;
          this.hideDaysOff();

          // Highlight today, if it's in the range of the view
          //TODO: compare con dateStart e dateEnd
          /*
          if (today.compare(dateList[0]) != -1 &&
              today.compare(dateList[dateList.length-1]) != 1) {
              this.findDayBoxForDate(today).setAttribute("today", "true");
          }
          */
          this.adjustWeekdayLength();
        ]]></body>
      </method>

      <method name="hideWeekNumbers">
        <body><![CDATA[
        let rows = this.yeargridrows.childNodes;
        for (let i = 0; i < rows.length; i++) {
          let row = rows[i];
          rowdate = this.mStartDate.clone();
          rowdate.month = i;
          let date = rowdate.clone();

          for (let jj = rowdate.weekday; jj < rowdate.endOfMonth.day+rowdate.weekday; jj++) {
              j=jj+1;
        	  let daybox = row.childNodes[j];
        	  let weekLabel = document.getAnonymousElementByAttribute(daybox, "anonid", "week-label");
        	  weekLabel.hidden = true;
          }
        }
        ]]></body>
      </method>

      <method name="hideDaysOff">
        <body><![CDATA[
          var columns = document.getAnonymousElementByAttribute(this, "anonid", "yeargridcolumns").childNodes;
          let headerkids = document.getAnonymousElementByAttribute(this, "anonid", "labeldaybox").childNodes;
          for (var i in columns) {
            var dayForColumn = (Number(i) + this.mWeekStartOffset) % 7;
            var dayOff = (this.mDaysOffArray.indexOf(dayForColumn) != -1);
            columns[i].collapsed = dayOff && !this.mDisplayDaysOff;
            headerkids[i].collapsed = dayOff && !this.mDisplayDaysOff;
          }
        ]]></body>
      </method>

      <method name="findDayBoxForDate">
        <parameter name="aDate"/>
        <body><![CDATA[
          for (var k in this.mDateBoxes) {
            var box = this.mDateBoxes[k];
            if (box.mDate!=null && box.mDate.compare(aDate) == 0)
              return box;
          }
          return null;
        ]]></body>
      </method>

      <method name="findDayBoxesForItem">
        <parameter name="aItem"/>
        <body><![CDATA[
          var targetDate = null;
          var finishDate = null;
          var boxes = new Array();

          // All our boxes are in default tz, so we need these times in them too.
          if (cal.item.isEvent(aItem)) {
            targetDate = aItem.startDate.getInTimezone(this.mTimezone);
            finishDate = aItem.endDate.getInTimezone(this.mTimezone);
          } else if (cal.item.isToDo(aItem)) {
            if (aItem.entryDate) {
              targetDate = aItem.entryDate.getInTimezone(this.mTimezone);
              if (aItem.dueDate) {
                finishDate = aItem.dueDate.getInTimezone(this.mTimezone);
              }
            }
          }

          if (!targetDate)
            return boxes;

          if (!finishDate) {
            let maybeBox = this.findDayBoxForDate(targetDate);
            if (maybeBox) {
              boxes.push(maybeBox);
            }
            return boxes;
          }

          if (!targetDate.isDate) {
            // Reset the time to 00:00, so that we really get all the boxes
            targetDate.hour = 0;
            targetDate.minute = 0;
            targetDate.second = 0;
          }

          if (targetDate.compare(finishDate) == 0) {
              // Zero length events are silly, but we have to handle them
              let box = this.findDayBoxForDate(targetDate);
              if (box) {
                  boxes.push(box);
              }
          }

          while (targetDate.compare(finishDate) == -1) {
            let box = this.findDayBoxForDate(targetDate);

            // This might not exist, if the event spans the view start or end
            if (box) {
                boxes.push(box);
            }
            targetDate.day += 1;
          }

          return boxes;
        ]]></body>
      </method>

      <method name="doAddItem">
        <parameter name="aItem"/>
        <body><![CDATA[

          let boxes = this.findDayBoxesForItem(aItem);

          if (!boxes.length)
            return;

          boxes.forEach(box => {
            box.addItem(aItem);
          });
        ]]></body>
      </method>

      <method name="doDeleteItem">
        <parameter name="aItem"/>
        <body><![CDATA[
          this.mItemsSlot = {};
          let boxes = this.findDayBoxesForItem(aItem);

          if (!boxes.length)
            return;

          function isNotItem(a) {
              return (a.hashId != aItem.hashId);
          }
          var oldLength = this.mSelectedItems.length;
          this.mSelectedItems = this.mSelectedItems.filter(isNotItem);

          boxes.forEach(box => {
            box.deleteItem(aItem);
          });

          // If a deleted event was selected, we need to announce that the
          // selection changed.
          if (oldLength != this.mSelectedItems.length) {
              this.fireEvent("itemselect", this.mSelectedItems);
          }
        ]]></body>
      </method>

      <method name="deleteItemsFromCalendar">
        <parameter name="aCalendar"/>
        <body><![CDATA[
          let deleteHash = {};
          this.mDateBoxes.forEach(box => {
            let boxItemData = Array.slice(box.mItemData);
            boxItemData.forEach(itemData => {
              let item = itemData.item;
              if (!deleteHash[item.hashId] && item.calendar.id == aCalendar.id) {
                deleteHash[item.hashId] = true;
                this.doDeleteItem(item);
              }
            });
          });
        ]]></body>
      </method>

      <method name="flashAlarm">
        <parameter name="aAlarmItem"/>
        <parameter name="aStop"/>
        <body><![CDATA[
          var showIndicator = Preferences.get("calendar.alarms.indicator.show", true);
          var totaltime = Preferences.get("calendar.alarms.indicator.totaltime", 3600);

          if (!aStop && (!showIndicator || totaltime < 1)) {
            // No need to animate if the indicator should not be shown.
            return;
          }

          // Make sure the flashing attribute is set or reset on all visible
          // boxes.
          let boxes = this.findDayBoxesForItem(aAlarmItem);
          if (this.mDateBoxes !== null) {
              this.mDateBoxes.forEach(box => {
                let boxItemData = Array.slice(box.mItemData);
                boxItemData.forEach(itemData => {
                  if (itemData.item.hasSameIds(aAlarmItem)) {
                    if (aStop) {
                      itemData.box.removeAttribute("flashing");
                    } else {
                      itemData.box.setAttribute("flashing", "true");
                    }
                  }
                });
              });
          }

          if (!aStop) {
            // Set up a timer to stop the flashing after the total time.
            var this_ = this;
            this.mFlashingEvents[aAlarmItem.hashId] = aAlarmItem;
            setTimeout(function() { this_.flashAlarm(aAlarmItem, true) }, totaltime);
          } else {
            // We are done flashing, prevent newly created event boxes from flashing.
            delete this.mFlashingEvents[aAlarmItem.hashId];
          }
        ]]></body>
      </method>

    </implementation>

    <handlers>
      <handler event="DOMMouseScroll"><![CDATA[
        let scrollEnabled = Preferences.get('calendar.view.mousescroll', true);
        if (!event.ctrlKey &&
            !event.shiftKey &&
            !event.altKey &&
            !event.metaKey &&
            scrollEnabled) {
            // In the month view, the only thing that can be scrolled
            // is the month the user is in. calendar-base-view takes care
            // of the shift key, so only move the view when no modifier
            // is pressed.
            this.moveView(event.detail < 0 ? -1 : 1);
        }
      ]]></handler>
    </handlers>

  </binding>
</bindings>
